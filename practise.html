<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    
    <script>
        /* map的实现 
        **/
        Array.prototype.myMap = function(callbackFn, thisArg) {
            // 判断条件
            // this必须是一个数组
            if(this === null || this === undefined) {
                throw new Error("Cannot read property of 'map' of null or undefined")
            }
            if(this && Object.prototype.toString.call(this) !== '[object Array]') {
                throw new Error('Invalid or unexcepted token')
            }
            // 处理回调函数
            if(Object.prototype.toString.call(callbackFn) !== "[object Function]") {
                throw new Error(callbackFn + ' is not a function')
            }

            // ecma262草案中，规定，将this转换为对象
            let O = To_Object(this)
            let T = thisArg

            let len = O.length >>> 0
            let resAr = new Array(len)
            for(let k = 0; k < len; k++) {
                // in 在原型链上查找
                if(k in o) {
                    let kValue = O[k]
                    let mapValue = callbackFn.call(T, kValue, k, O)
                    resAr[k] = mapValue
                }
            }

            return resAr
        }
        Array.prototype.myReduce = function(callbackFn, initialValue) {
            // 数组类型异常
            if(this === null || this === undefined) {
                throw new Error("Cannot read the property 'reduce' of null or undefined")
            }
            if(this && Object.prototype.toString.call(this) !== '[object Array]') {
                throw new Error("Invalid or unexpected token")
            }
            // 回调函数类型异常
            if(callbackFn && Object.prototype.toString.call(callbackFn) !== '[object Function]') {
                throw new Error(callbackFn + " is not a function")
            }
            // 拿到this和initialValue
            let O = To_Object(this)    // 这块内容是将this转换成对象，以便后面使用for in进行循环
            let len = O.length >>> 0
            let accumulatorVal = initialValue
            let k = 0
            // 如果初始值为空，把数组中的第一个数赋给保存计算结果变量
            if(accumulatorVal === undefined) {      //这里直接是undefined，不是'undefined'(这是个字符串)
                // accumulatorVal = O[k]
                // k++
                for(; k <len; k++) {
                    // 查找原型链
                    if(k in O) {
                        accumulatorVal = O[k]
                        k++
                        break
                    }
                }
            }
            // 数组全为空
            if(k === len && accumulatorVal === undefined) {
                throw new Error("Each element of the array is empty")
            }
            for(; k < len; k++) {
                if(k in O) {
                    accumulatorVal = callbackFn.call(null, accumulatorVal, O[k], k, O)
                }
            }
            return accumulatorVal
        }

        /* 数组扁平化
        let ary = [1, [2, [3, [4, 5]]], 6]
        // 方法1： 使用es6提供的数组新增的方法flat
        let flatRes = ary.flat(Infinity)
        // 方法2： 首先，调用toString()方法，将数组转换成字符串，然后处理成数组
        // let flatRes = ary.toString().split(',').map(item => parseInt(item))
        // 方法3： 使用正则，将所有的[]替换掉，剩余的是数字字符，然后进行处理
        // let flatRes = ary.join(',').replace(/\[|\]/g, '').split(',').map(item => Number(item))
        // 方法4： 利用some判断当前的项是否是数组
        // while(ary.some(Array.isArray)) {
        //     ary = [].concat(...ary)
        // }
        console.log(flatRes);
        **/

        /* js判断数组中是否包含某个值的四种方法
        let arr = [1,2,4,3,4,65,43,2,2,1]
        let findRes = arr.find((item, index, arr) => {
            // 满足条件的第一个数
            return item > 10
        })
        let findInd = arr.findIndex((item, index, arr) => {
            // 满足条件的第一个数的索引
            return item > 10
        })
        // 是否包含某个元素，返回true/false
        let includesRes = arr.includes(0)
        // 返回某个元素首次出现的位置
        let indexof = arr.indexOf(4)
        console.log(indexof);
        **/

        /* 中途停止forEach的执行：借助try catch实现。官网上提倡用some或every替换forEach的使用
            some是return true时触发停止；every是return false时触发停止。
        let arr = [1,2,4,5,6,7,3]
        try{
            arr.forEach((item, index) => {
                // console.log(index, item);
                // 抛出错误的位置写的时候也有说法，只需要记住，这些都属于同步任务，js会按顺序加载执行
                if(item > 4) {
                    throw new Error('item > 4')
                }
                console.log(index, item);
                
            })
        } catch(error) {
            console.log(error);
        }
        **/
        

        /* lc 16: 最接近的三数之和
        // 16: https://leetcode-cn.com/problems/3sum-closest
        let nums = [-1, 2, 1, -4], target = 1
        let threeSumsCloset = function(nums, target) {
            if(nums.length < 3) return false
            if(nums.length === 3) {
                return nums.reduce((sum, curItem) => sum + curItem, 0)
            }
            let min = 2**31, res
            // 这里注意：a: sort排序会直接在原数组上进行排序；b: 注意负数的排序
            nums.sort((a, b) => a - b)
            for(let i = 0; i < nums.length - 2; i++) {
                let j = i+1, k = nums.length - 1
                while(j < k) {
                    let sum = nums[i] + nums[j] + nums[k]
                    // let dis = (sum > target) ? (sum - target) : (target - sum)
                    // res = dis < min ? sum : res
                    // min = Math.min(min, dis)
                    let dis = Math.abs(sum - target)
                    if(dis < min) {
                        min = dis
                        res = sum
                    }
                    if(sum > target) {
                        --k
                    } else if(sum < target) {
                        ++j
                    } else {
                        return sum
                    }
                }
            }

            return res
        }
        console.log(threeSumsCloset(nums, target));
        **/
        

        /* in   for in   hasOwnProperty   
        function Person(){
        };
        Person.prototype.name = "hello";
        Person.prototype.age = "12";
        Person.prototype.sayName = function(){alert(this.name);};
        
        var p1 = new Person();
        // Object.defineProperty(p1.__proto__,"name",{enumerable:false});
        Object.defineProperty(p1,"name",{value: 'p1Name', enumerable:false});
        
        // p1.__proto__.name = 'name'
        console.log(Person.prototype, p1);
        console.log(p1.hasOwnProperty("name"));
        // for(var ii in Person.prototype){
        //     console.log(ii, Person.prototype[ii]);
        // }
        for(var ii in p1){
            console.log(ii, p1[ii]);
        }
        **/

        /* proxy的简单使用
        var person = {
            name: "张三"
        };
        handler = {
            get(target, property){
                if(property in target){
                // if(target[property]) {
                    console.log('target', target.__proto__);
                    return target[property]
                }else{
                    throw new ReferenceError("Property \"" + property + "\" does not exist.")
                }
            }
        }

        var proxy = new Proxy(person, handler)

        **/
        
        /* 查找表问题：两个数组的交集 利用map set
        let intersect = function(nums1, nums2) {
            let arrRes = []
            let map1 = buildMap(nums1), map2 = buildMap(nums2)

            for(let key of map1.keys()) {
                let map2Has = map2.get(key)
                if(map2Has) {
                    let map1Has = map1.get(key)
                    let count = Math.min(map2Has, map1Has)
                    for(let j = 0; j < count; j++) {
                        arrRes.push(key)
                    }
                }
            }
            return arrRes
        }
        let buildMap = function(arr) {
            let map = new Map()
            for(let i = 0; i < arr.length; i++) {
                // 取出当前的item对应的value
                let count = map.get(arr[i])
                if(count) {
                    map.set(arr[i], count+1)
                } else {
                    map.set(arr[i], 1)
                }
            }
            return map
        }
        let arr1 = [2,3,3,5,6,3], arr2 = [3,3,5,7,3]
        console.log(intersect(arr1, arr2));
        **/
        

        /* vue中的监听数据变化的研究
        // 还是老套路，定义一个observe方法
        function defineReactive(data, key, val) {
            Object.defineProperty(data, key, {
                enumerable: true,
                configurable: true,
                get: function defineGet() {
                console.log(`get key: ${key} val: ${val}`)
                return val
                },
                set: function defineSet(newVal) {
                console.log(`set key: ${key} val: ${newVal}`)
                // 还记得我们上面讨论的闭包么
                // 此处将新的值赋给val，保存在内存中，从而达到赋值的效果
                val = newVal
                }
            })
        }
        function observe(data) {
        Object.keys(data).forEach(function(key) {
            defineReactive(data, key, data[key])
        })
        }

        let test = [1, 2, 3]
        // let test = {
        //     name: 'zhang',
        //     age: 0
        // }
        // 初始化
        console.log(observe(test));

        const aryMethods = ['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'];
        const arrayAugmentations = [];

        aryMethods.forEach((method)=> {

            // 这里是原生Array的原型方法
            let original = Array.prototype[method];

        // 将push, pop等封装好的方法定义在对象arrayAugmentations的属性上
        // 注意：是属性而非原型属性
            arrayAugmentations[method] = function () {
                console.log('我被改变啦!');

                // 调用对应的原生方法并返回结果
                return original.apply(this, arguments);
            };
        });

        let list = ['a', 'b', 'c'];
        // 将我们要监听的数组的原型指针指向上面定义的空数组对象
        // 别忘了这个空数组的属性上定义了我们封装好的push等方法
        list.__proto__ = arrayAugmentations;
        list.push('d');  // 我被改变啦！ 4

        // 这里的list2没有被重新定义原型指针，所以就正常输出
        let list2 = ['a', 'b', 'c'];
        list2.push('d');  // 4
        **/

        /** 前序中序构建树
         let preorder = [1,2], inorder = [2,1]
        // let preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]
        let buildTree = function(preorder, inorder) {
            if(preorder.length === 0 || inorder.length === 0 || preorder.length !== inorder.length) {
                return null
            }
            let node = new TreeNode()
            let res = node

            let runFn = function(preArr, inArr, node) {
                let root = preArr[0]
                node.val = root
                // root在中序数组中的位置
                let rootIndex = inArr.indexOf(root)
                // 左右中序数组
                let leftInArr = inArr.slice(0, rootIndex),
                    rightInArr = inArr.slice(rootIndex + 1)
                // 左右中序数组为空，
                if(leftInArr.length === 0 || rightInArr.length === 0) {
                    return
                }
                let leftPreArr = preArr.slice(1, leftInArr.length + 1),
                    rightPreArr = preArr.slice(leftInArr.length + 1)
                node.left = new TreeNode()
                node.right = new TreeNode()
                runFn(leftPreArr, leftInArr, node.left)
                runFn(rightPreArr, rightInArr, node.right)
            }
            runFn(preorder, inorder, node)
            return res
        }
        let buildTreeSec = function(preorder, inorder) {
            // current node
            if(!preorder.length || !inorder.length) {
                return null
            }
            const curRoot = preorder[0]
            const node = new TreeNode(curRoot)
            let i = 0
            for(; i < inorder.length; i++) {
                if(inorder[i] === curRoot) {
                    break
                }
            }
            // left node
            node.left = buildTreeSec(preorder.slice(1, i+1), inorder.slice(0, i))
            // right node
            node.right = buildTreeSec(preorder.slice(i+1), inorder.slice(i+1))
            return node
        }
        function TreeNode(val) {
            this.val = val
            this.left = this.right = null
        }
        console.log(buildTreeSec(preorder, inorder));
         * **/
        

        /** promise的使用，有问题
        let fun = function(a, b) {
            return new Promise((resolve, reject) => {
                if(a > b) {
                    resolve('success')
                } else {
                    reject('error')
                }
            })
        }
        console.log(fun(1, 0));
         * **/
        
        /** 排序，冒泡、快排、插入，待补充其余
        let arr = [17, 3, 35, 4, 20, 33]
        let puppleSort = function (arr) {
            // 控制比较的次数
            for(let i = 0; i < arr.length - 1; i++) {
                // 控制当前数组是否已有序，有序则无需继续比较，直接return即可
                let exchange = 0
                // 元素的比较
                for(let j = arr.length - 1; j > i; j--) {
                    if(arr[j] < arr[j - 1]) {
                        [arr[j], arr[j-1]] = [arr[j-1], arr[j]]
                        exchange = 1
                    }
                }
                if(exchange === 0) {
                    return arr
                }
            }
            return arr
        }
        let quickSort = function(arr) {
            let sortFn = function(curArr) {
                if(curArr.length <= 1) return curArr
                let left = [], right = []
                let prior = curArr.splice(0, 1)[0]
                for(let i = 0; i < curArr.length; i++) {
                    let item = curArr[i]
                    if(item >= prior) {
                        right.push(item)
                    } else {
                        left.push(item)
                    }
                }
                return sortFn(left).concat([prior], sortFn(right))
            }
            return sortFn(arr)
        }
        let insertSort = function(arr) {
            // var len = arr.length,
            //     i, j, tmp, result;
            
            // // 设置数组副本
            // result = arr.slice(0);
            // for(i=1; i < len; i++){
            //     tmp = result[i];
            //     j = i - 1;
            //     while(j>=0 && tmp < result[j]){
            //     result[j+1] = result[j];
            //     j--;
            //     }
            //     result[j+1] = tmp;
            // }
            // return result;
            
            for(let i = 1; i < arr.length; i++) {
                let j = i - 1, tem = arr[i]
                while(j >= 0 && tem < arr[j]) {
                    arr[j+1] = arr[j]
                    j--
                }
                arr[j+1] = tem
            }
            return arr
        }
        // console.log(insertSort(arr));
         * **/
        

        /** 链表反转
        let head = [1,3,2]
        var reservePrint = function(node) {
            if(!node) return []
            let arr = []
            while(node !== null) {
                arr.push(node.val)
                node = node.next
            }

            return arr.reverse()
        }
        console.log(reservePrint(head));
         * **/
        

        /** 删除字符串中只出现一次的字符
        let str = 'ddagdsdddsaafdfvdchhyfvvgnbg'
        function minLen(str) {
            str = str.split('').sort().join('')
            let newStr = ''

            str.replace(/(\w)\1+/g, (data, item) => {
                console.log(data, item);
                newStr += data
            })
            return newStr
        }
        console.log(minLen(str));
         * **/
        

        /** 组合数最小
        let arr = [3,30,34,5,9]
        let minNumber = function(arr) {
            // boundary
            if(arr.length < 1) return ''
            let str = '', tem = []

            str = arr.sort((a, b) => {
                return ('' + a + b) - ('' + b + a)
            }).join('')

            // tem = arr.map(item => item + '')
            // tem.sort((a, b) => {
            //     if(a + b > b + a) {
            //         return 1
            //     } else {
            //         return -1
            //     }
            // })
            // console.log(tem);
            // str = tem.join('')
            
            return str
        }
        console.log(minNumber(arr));
         * **/
        

        /** 数组元素相乘
        let arr = [1,2,3,4]
        let getMutil = function(arr){
            if(arr.length === 0) return []
            let resArr = [], temp = 1
            resArr[0] = 1
            for(let i = 1; i < arr.length; i++) {
                resArr[i] = resArr[i-1] * arr[i-1]
            }
            for(let j = arr.length -2; j >= 0; j--) {
                temp *= arr[j+1]
                resArr[j] *= temp
                
            }

            return resArr
        }
        console.log(getMutil(arr));
         * **/
        

        /** 数组中不重复的数
            let singleNumbers = function(arr) {
                if(!arr.length) {
                    return []
                }
                let res1 = ''
                arr.sort()
                for(let i = 0; i < arr.length; i++) {
                    if(arr[i+1] && arr[i] === arr[i+1]) {
                        i++
                    } else if(arr[i] !== arr[i+1]) {
                        res1 += arr[i] + ','
                    }
                }
                res1 = res1.substr(0, res1.length - 1)
                return res1.split(',').map(item => parseInt(item))
            }

         * **/
        
        /** 二叉树的先序遍历
            var pathSum = function(root, sum) {
                // boundary
                // if(treeNode)  if(sum)
                if(!root) {
                    return []
                }
                var res = [], arr = []
                __pushArr(root, sum, arr, res)
                return res
            }
            function __pushArr(root, curSum, arr, res) {
                if(!root) {
                    return
                }
                // 将当前的值存入arr中
                arr = [...arr, root.val]

                if(!root.left && !root.right && root.val === curSum) {
                    res.push(arr)
                    return;
                }
                __pushArr(root.left, curSum - root.val, arr, res)
                __pushArr(root.right, curSum - root.val, arr, res)
            }

         * **/
        
        /** 查找一个字符串在另一个字符串中出现的位置
            let strStr = function(str1, str2) {
                // str1为空：-1； str1的长度小于str2：-1
                if(!str1 || str1.length < str2.length) return -1
                // str2为空：0
                if(!str2) return 0
                // 
                for(let i = 0; i < str1.length - str2.length + 1; i++) {
                    let tem = str1.substr(i,str2.length)
                    if(tem === str2) {
                        return i
                    }
                }
                return -1
            }
            let str1 = 'abcded', str2 = 'cd'
            console.log(strStr(str1, str2));
         * **/
        

        /** 数组查找数据
        let nums = [0,1,2,2,3,0,4,2], val = 2
        function deleteVal(nums, val) {
            if(nums.length < 1) return 0

            nums.sort((a, b) => a-b)
            for(let i = 1; i < nums.length; i++) {
                if(nums[i] === 2) {
                    nums.splice(i, 1)
                    i--
                    continue
                }
                if(nums[i] > val) {
                    return nums.length
                }
            }

            // 无效nums.forEach((item, index) => {
            //     console.log('index', index, item, nums.length);
            //     if(item === val) {
            //         nums.splice(index, 1)
            //     }
            // })
            
            // while(nums.indexOf(val) !== -1) {
            //     let index = nums.indexOf(val)
            //     nums.splice(index, 1)
            // }
            return nums.length
        }
        console.log(deleteVal(nums, val));
         * **/
        

        /* a == 1 && a == 2 && a == 3
            // const a = {
            //     count: 0,
            //     toString: function() {
            //         return ++this.count
            //     }
            // }
            
            const a = [1, 2, 3]
            a.toString = a.shift
            if(a == 1 && a == 2 && a == 3) {
                console.log('ok');
            }
        **/

        /*  对象转数组
            let obj = {
                1: 222,
                2: 33,
                5: 999
            }
            // [222, 33, null, null, 999, null, null, null, null, null, null, null, null]
            // let arr = new Array(12).fill(null)
            // arr = arr.map((item, index) => {
            //     return obj[index + 1] || null
            // })

            // let arr = new Array(12).fill(null)
            // Object.keys(obj).forEach((item, index) => {
            //     arr[item - 1] = obj[item]
            // })
            
            obj.length = 13
            let arr = Array.from(obj).slice(1)
            arr = arr.map(item => item || null)
            console.log(arr);
        **/
        
        /** 对象重定义数组方法的实例练习
         * // [].push(1)
            // function push(a) {
            //     this[this.length] = a
            //     // this.length + 1
            //     return this.length
            // }
            let obj = {
                2: 3,   // 2: 1
                3: 4,   //3: 2
                length: 2,  // length: 3
                push: Array.prototype.push
            }
            obj.push(1)
            // obj[obj.length] = 1  obj[2] = 1  obj.length + 1 = 3
            obj.push(2)
            // obj[obj.length] = 2  obj[3] = 2  obj.length + 1 = 4
            obj.push(3)
            // obj[obj.length] = 3  obj[4] = 3  obj.length + 1 = 5
            console.log(obj);
         * **/
        
        /** 空格替换
         * var replaceSpace = function(str) {
                if(!str) return str
                return str.replace(/\s+/g, '%20')
            }
            const str = 'you are so nice'
            console.log(replaceSpace(str));
         * **/

        /**任意一个重复的数字
         * @param {number[]} nums
         * 
         * @return {number}
         * 
            var findRepeatNumber = function(nums) {
                if(!nums.length) return
                let set = new Set()
                for(let i = 0; i < nums.length; i++) {
                    if(!set.has(nums[i])) {
                        set.add(nums[i])
                    } else {
                        return nums[i]
                    }
                }

                // nums.sort()
                // for(let i = 1; i < nums.length; i++) {
                //     if(nums[i] === nums[i-1]) {
                //         return nums[i]
                //     }
                // }

                // for(let i = 0; i < nums.length; i++) {
                //     let res = nums.slice(i+1)
                //     if(res.indexOf(nums[i]) !== -1) {
                //         return nums[i]
                //     }
                // }
                // return number
            };
            let nums = [1,2,4,3,9,3]
            console.log(findRepeatNumber(nums));
         */
        

        // 倒计时
        /**
         * 
        function show() {
            var d1 = new Date();//获取当前时间
            var d1Ms = d1.getTime();
            var d2 = new Date(2022, 1, 4, 20, 0, 0);
            var d2Ms = d2.getTime();
            var differMs = d2Ms - d1Ms;//相差的毫秒数
            var date = parseInt(differMs / (3600 * 24 * 1000));//天
            var hours = parseInt((differMs % (3600 * 24 * 1000)) / (3600 * 1000));//1小时=3600s
            var minutes = parseInt((differMs % (3600 * 1000)) / (60 * 1000));//分钟
            var seconds = parseInt((differMs % (60 * 1000)) / 1000);//秒
            var ms = differMs % 1000;//毫秒
            //当前分秒为各位数字时,对其进行的处理
            hours = hours < 10 ? "0" + hours : hours;
            minutes = minutes < 10 ? "0" + minutes : minutes;
            seconds = seconds < 10 ? "0" + seconds : seconds;
            if(document.getElementById("spanTime")){

                document.getElementById("spanTime").style.fontSize='40px'
                document.getElementById("spanTime").innerHTML = "距北京2022年冬奥会" + '&nbsp;&nbsp;&nbsp;&nbsp;' + date + "天" + '&nbsp;&nbsp;' + hours + "小时" + '&nbsp;&nbsp;' + minutes + "分" + '&nbsp;&nbsp' + seconds + "秒";

            }
        }

         * **/
        
        // longestCommonPrefix
        /*
            var longestCommonPrefix = function(arr) {
                if(arr.length <= 1) return arr
                let pre = arr[0]
                for(let i = 1; i < arr.length; i++) {
                    let j = 0
                    for(; j < pre.length && j < arr[i].length; j++) {
                        if(pre[j] !== arr[i][j]) {
                            break
                        }
                    }
                    pre = pre.substring(0, j)
                    // pre = pre.slice(0, j)
                }
                return pre
            }
            let arr = ['flow', 'flower', 'fly']
            console.log(longestCommonPrefix(arr));

        **/
        
        // Number reverse
        /**
         * var reverse = function(x) {
            // x是数字
            x = isNaN(x) ? 0 : Number(x)
            // if 0, return x directly
            if(x === 0) return 0
            let res = 0, sym = 0
            // x < 0
            if(x < 0) {
                sym = 1
                x = 0 - x
            }
            // x > 0
            while(x) {
                res = res * 10 + x % 10
                x = Math.floor(x / 10)
            }
            if(res >= 2**31) return 0
            res = sym === 1 ? -res : res
            
            return res
        }
        var reverseN = function(x) {
            const border = 2**31
            const res = (x > 0 ? 1 : -1)*x.toString().split('').filter(x => x !== '-').reverse().join('')
            return res < -border || res > border -1 ? 0 : res
        }
        console.log(reverse('-q10'));
        var reverse = function(x) {
            let result = 0;
            while(x !== 0) {
                result = result * 10 + x % 10;
                x = (x / 10) | 0;
            }
            return (result | 0) === result ? result : 0;
        };
        var reverse = function(x) {
            const border = 2**31
            const max = border - 1
            const min = -border

            const result = (x > 0 ? 1 : -1) * String(x).split('').filter(x => x !== '-').reverse().join('')
            return result > max || result < min ? 0 : result 
        };

         * */
        

    </script>
</body>
</html>